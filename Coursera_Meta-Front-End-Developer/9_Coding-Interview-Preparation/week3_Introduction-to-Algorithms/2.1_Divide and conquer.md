The divide and conquer paradigm offers a useful framework for thinking about how to solve a given problem.

It encompasses two principles discussed in this module, namely, recursion and breaking problems down into smaller problems.

In this video, you will learn about the divide and conquer paradigm and how it offers a framework for problem solving.

You will also learn about the mandatory and optional steps involved in the divide and conquer paradigm and what advantages this paradigm brings to computers.

So how does the divide and conquer algorithm work? The algorithm comprises two steps with an optional third, namely, divide and conquer, which are the mandatory steps and combine, which is an optional step.

In the divide step, the input is split into smaller segments and processed individually.

In the conquer step, every task associated with a given segment is solved.

The optional last step, combine, is combining all the solved segments.

This will not happen in every instance, but will for the example provided.

The following is an example of the divide and conquer paradigm.

When discussing sorting approaches, it was shown that there are many ways to solve a problem.

Using sorting as our example, let's discuss another sorting approach that can be solved using a divide and conquer approach.

Merge sort is a sophisticated approach for sorting an array.

It starts by having the array, these two halves and then halved, and halved again.

This process is repeated until there is only one element remaining, then, the process reverses and each smaller list is sorted before rejoining the part it was halved from.

This solution to a problem is based on the idea that by breaking a problem into smaller problems, it is easier to complete the overall task.

To gain greater intuition on how divide and conquer can be applied to merge sort, let us explore a real world example.

Consider you and three housemates have decided to do the shopping together.

After having compiled an extensive list, you all go to the supermarket.

One solution might be that you all walk around the supermarket and pick up each item from the list.

A better approach might be to break the list into four parts and each take a section, this would reduce the overall time spent in the shop.

Though this might cause an amount of overlap between parties, a further optimization of the task then might be to first sort the list.

So that all similar items are together, for example, all the beverages, the fruits, the meats and so on.

Then, assign each member a given area of the supermarket, this would be an even more efficient approach to completing the task.

They say a problem shared is a problem halved.

So how does this work on computers? There are two immediate advantages namely, parallelization and memory management.

Parallelism is when you have different threads or computers working on the same problem at the same time to complete it in a quicker time.

A benefit to employing divide and conquer solutions is that you can then employ parallelism when coding.

Now, let's explore memory management.

With the merge sort example, consider that each array can be sent to a different core or server depending on the architecture of your organization and the results are then returned.

It might be the data being processed is too large to hold in memory and must be processed in chunks.

Additionally, the boss may have provisioned access to cloud computing.

So the solution can involve accessing an online server and exporting some of the problems from the company servers.

All this contributes to managing your available memory.

In this video, you were introduced to the paradigm of divide and conquer through an example of merge sort and how it offers a framework for problem solving.

Some various terminology associated with it, as well as how this approach lends itself to real world computer optimization approaches were demonstrated.

You also learned about the mandatory and optional steps involved in the divide and conquer paradigm, and what advantages this paradigm brings to computers.



分而治之的范式为思考如何解决给定问题提供了一个有用的框架。

它包含本模块中讨论的两个原则，即递归和将问题分解为更小的问题。

在本视频中，您将了解分而治之范式以及它如何提供解决问题的框架。

您还将了解分而治之范式中涉及的强制和可选步骤，以及该范式给计算机带来的优势。

那么分治算法是如何工作的呢？该算法包括两个步骤和可选的第三个步骤，即分而治之（强制步骤）和组合（可选步骤）。

在分割步骤中，输入被分割成更小的片段并单独处理。

在征服步骤中，与给定段相关的每个任务都得到解决。

可选的最后一步“组合”是组合所有已解决的片段。

这不会在所有情况下发生，但对于所提供的示例会发生。

以下是分而治之范式的示例。

在讨论排序方法时，结果表明解决问题的方法有很多种。

以排序为例，让我们讨论另一种可以使用分而治之的方法来解决的排序方法。

合并排序是一种对数组进行排序的复杂方法。

它从数组开始，分成两半，然后减半，再减半。

重复这一过程，直到只剩下一个元素，然后，该过程反转，对每个较小的列表进行排序，然后重新加入它被减半的部分。

这种问题的解决方案基于这样的想法：通过将问题分解为更小的问题，可以更容易地完成整体任务。

 为了更直观地了解如何将分而治之应用于合并排序，让我们探索一个现实世界的示例。

假设您和三个室友决定一起购物。

列好一份详尽的清单后，你们就去超市了。

一种解决方案可能是大家在超市里走一圈，然后从清单中挑选每件商品。

更好的方法可能是将清单分成四个部分，每个部分占一个部分，这将减少在商店中花费的总时间。

尽管这可能会导致各方之间出现大量重叠，但任务的进一步优化可能是首先对列表进行排序。

因此，所有类似的物品都放在一起，例如所有饮料、水果、肉类等。

然后，为每个成员分配超市的特定区域，这将是完成任务的更有效的方法。

他们说，共同解决问题，问题就减半。

那么这在计算机上是如何工作的呢？有两个直接的优点，即并行化和内存管理。

并行是指让不同的线程或计算机同时处理同一问题以更快地完成它。

采用分而治之解决方案的好处是您可以在编码时采用并行性。

现在，让我们探讨一下内存管理。

对于合并排序示例，请考虑根据组织的体系结构将每个数组发送到不同的核心或服务器，然后返回结果。

可能是正在处理的数据太大而无法保存在内存中，必须分块处理。

此外，老板可能已经提供了对云计算的访问权限。

因此，解决方案可能涉及访问在线服务器并从公司服务器导出一些问题。

 所有这些都有助于管理您的可用内存。

在本视频中，通过合并排序的示例向您介绍了分而治之的范例以及它如何提供解决问题的框架。

演示了与之相关的一些不同术语，以及这种方法如何适用于现实世界的计算机优化方法。

您还了解了分而治之范式中涉及的强制性和可选步骤，以及该范式给计算机带来的优势。

