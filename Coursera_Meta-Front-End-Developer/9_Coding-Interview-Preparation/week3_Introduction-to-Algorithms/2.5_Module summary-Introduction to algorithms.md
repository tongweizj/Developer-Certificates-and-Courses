
Well done.

You've reached the end of the working with algorithms module.

Let's take a few moments to review what you learned during this module.

We began the module with a lesson on sorting and searching.

First, you learned about why sorting is important and explored the three main methods for sorting selection, insertion, and quick sort.

And examined the steps involved for each method that these algorithms used to sort data.

And explore the strengths and weaknesses of the three sorting approaches when choosing an algorithm to use for a given solution.

Importantly, that there is not one sorting algorithm that provides the best results in every given scenario.

Next, you learned about searching algorithms, which are a fundamental concept in computer science and some of the various methods that are used by algorithms for searching.

You explored two core approaches to searching linear and binary.

Linear searches progress through every item in a given data structure until a specific item is found whereas binary search is half the search space at each iteration.

You also learned the steps involved in implementing both approaches and some of the advantages they offer.

You also took a deep dive into time and space complexity for both searching and sorting algorithms.

You then moved on to the next lesson where you were introduced to working with algorithms.

Here, you learned about different approaches to working with algorithms.

First, you explored the divide and conquer paradigm.

In the divide step, the input is split into smaller segments and processed individually.

In the conquer step, every task associated with a given segment is solved, and the optional last step is combining all the solved segments.

And you discovered how the divide and conquer technique offers an effective framework for problem solving and the various benefits that it provides.

Next, you explored another important algorithmic approach recursion.

Recursion is when a function calls itself with a smaller instance of a problem repeatedly until some exit condition is met.

And you learned that there are three requirements for implementing a recursive solution, namely the base case, the diminishing structure, and the recursive call.

You were then introduced to dynamic programming, which is a programming paradigm that promotes solving problems by breaking them into smaller problems.

You explored the concept of memorization, the technique of solving sub problems, and storing them to save time on a potential future search.

And to examine the process involved to compute a dynamic programming solution, essentially, this can be outlined as first determining the objective function, that is the description of what the optimum outcome is to be.

Next, breaking the problem into smaller steps and then deciding which dynamic programming approach you would like to apply to achieve your desired outcome.

Finally, you learned about greedy algorithms.

In comparison to the dynamic programming approach, a greedy approach would look at the list of solutions and implement a local optimization, usually the current most rewarding option is chosen.

You've explored how a greedy algorithm approach could be implemented to reach a solution.

And note that there is a trade off when choosing a greedy approach over a dynamic one.

While the overhead for a greedy algorithm is low and coding a solution is quite straightforward, it will not always guarantee that the best option is returned.

With all the knowledge you have acquired, all that is left is to complete the final quiz for this module before moving on to the final module, where you will complete the graded assessment.

And then you've really made it, you're so close, good luck, and enjoy the rest of your journey.
做得好。

您已经完成了算法模块的使用。

让我们花一些时间回顾一下您在本模块中学到的内容。

我们以有关排序和搜索的课程开始该模块。

首先，您了解了排序为何如此重要，并探索了排序选择、插入和快速排序的三种主要方法。

并检查了这些算法用于对数据进行排序的每种方法所涉及的步骤。

并在选择用于给定解决方案的算法时探索三种排序方法的优点和缺点。

重要的是，没有一种排序算法可以在每种给定场景中提供最佳结果。

接下来，您了解了搜索算法，这是计算机科学中的基本概念，以及算法用于搜索的一些不同方法。

您探索了搜索线性和二进制的两种核心方法。

线性搜索会遍历给定数据结构中的每个项目，直到找到特定项目，而二分搜索在每次迭代时只占用搜索空间的一半。

您还了解了实施这两种方法所涉及的步骤以及它们提供的一些优势。

您还深入研究了搜索和排序算法的时间和空间复杂性。

然后，您继续学习下一课程，向您介绍如何使用算法。

在这里，您了解了使用算法的不同方法。

首先，您探索了分而治之的范式。

在分割步骤中，输入被分割成更小的片段并单独处理。

在征服步骤中，解决与给定分段相关的每个任务，并且可选的最后一步是组合所有已解决的分段。

 您还发现了分而治之技术如何为解决问题提供有效的框架以及它提供的各种好处。

接下来，您探索了另一种重要的算法方法递归。

递归是指函数用问题的较小实例重复调用自身，直到满足某些退出条件。

您还了解到，实现递归解决方案需要三个要求，即基本情况、递减结构和递归调用。

然后向您介绍了动态编程，这是一种通过将问题分解为更小的问题来促进解决问题的编程范例。

您探索了记忆的概念、解决子问题的技术以及存储它们以节省未来潜在搜索的时间。

为了检查计算动态规划解决方案所涉及的过程，本质上可以将其概述为首先确定目标函数，即最佳结果的描述。

接下来，将问题分解为更小的步骤，然后决定要应用哪种动态规划方法来实现所需的结果。

最后，您了解了贪婪算法。

与动态规划方法相比，贪心方法会查看解决方案列表并实施局部优化，通常会选择当前最有价值的选项。

您已经探索了如何实施贪婪算法方法来获得解决方案。

请注意，选择贪婪方法而不是动态方法时需要权衡。

虽然贪婪算法的开销很低并且编码解决方案非常简单，但它并不总是保证返回最佳选项。

 掌握了您所掌握的所有知识后，剩下的就是完成本模块的最终测验，然后再进入最终模块，您将在其中完成评分评估。

然后你就真的成功了，你已经很接近了，祝你好运，并享受你剩下的旅程。

