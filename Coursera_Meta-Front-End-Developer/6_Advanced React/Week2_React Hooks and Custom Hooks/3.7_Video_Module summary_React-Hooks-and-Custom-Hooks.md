# 3.7_Video_Module summary_React Hooks and Custom Hooks

Well done.

You've reached the end of this module on React hooks and custom hooks.

Throughout this module, you've explored hooks and React in depth and covered many important concepts and practical applications that will benefit you as you progress through the course.

It's now time to recap the key lessons you've learned and skills you've gained.

Your first lesson focused on the useState hook, which is used to work with state in a React component.

You've explored how to perform array destructuring using the useState hook and update state when using new state through the state updating function, and even how to change state and response to user generated events like button clicks.

You then worked through a detailed demonstration, learning how to use the useState hook within a component, including how to declare, read, and update state.

Next, you learned about side effects in relation to another important hook, the useEffect hook.

You discovered that side effects make a function impure with impure functions performing side effects such as invoking console log, fetch or the browser's geolocation functionality.

In addition to learning about the useEffect hook theoretically.

You learned how to use the useEffect hook to perform side effects within functional components and to control when the useEffect function is run using the dependency array through a practical demonstration.

Recall that the dependency array determines when the useEffect hook will be invoked.

Following the completion of Lesson 1 of this module, you should now be better positioned to work with state and React and to handle side effects in your components.

The second lesson of this module focused on the rules of hooks and fetching JSON data from the web.

First, you were introduced to the rules of hooks and React and unpacked them.

These rules are that you should only call hooks from a React component function and at the top level of a React component function or allowed to call multiple state hooks or effect hooks inside a component and should make multiple hook calls in the same sequence.

Next, in relation to the fetch function, you learned about the delegation of duties in JavaScript referred to as asynchronous JavaScript.

You also learned about the fetch function itself, which is a function that looks like it's part of JavaScript, but it's actually a way to call a browser API from JavaScript.

This led up to the lesson on fetching data using the state and effect hooks.

You worked through a demonstration where a call to the fetch API was used to get data from the web using React.

Now that you've completed this lesson, you should have greater insight into what happens if a developer doesn't follow the rules of hooks and React, and be able to describe how data is fetched in both JavaScript and React.

In the third lesson of this module, you learned about the useReducer hook and that it differs from the useState hook because it gets a reducer function in addition to the initial state.

You learned that the useReducer hook could be used in cases where they useState hook would be inefficient such as when you have complex state logic and how to implement the useReducer hook in your code.

You were also introduced to the concept of refs and how they can be used to go beyond the virtual DOM and access the underlying DOM elements as well as other applications, and have the opportunity to explore coding your own custom hooks.

By completing this lesson, you should be able to use the useReducer hook to track state as well as roll out your own hooks in your React apps.

You're making excellent progress.

Now that you have a solid grasp of working with hooks, it's time to take a deep dive into JSX, which I look forward to guiding you through in the next module.